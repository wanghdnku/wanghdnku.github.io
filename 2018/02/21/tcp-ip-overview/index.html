<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->

<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Hayden的个人博客">
  <meta name="keyword" content="">
  <meta name="theme-color" content="#600090">
  <meta name="msapplication-navbutton-color" content="#600090">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="#600090">
  <link rel="shortcut icon" href="https://avatars3.githubusercontent.com/u/11764996?s=460&v=4">
  <link rel="alternate" type="application/atom+xml" title="Hayden" href="/atom.xml">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
  <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.css">
  <title>

    TCP/IP 协议栈概述｜Hayden&#39;s Loft

  </title>

  <link rel="canonical" href="blog.hayden.fun/2018/02/21/tcp-ip-overview/">

  <!-- Bootstrap Core CSS -->
  <link rel="stylesheet" href="../../../../css/bootstrap.min.css">

  <!-- Custom CSS -->
  <link rel="stylesheet" href="../../../../css/blog-style.css">

  <!-- Pygments Github CSS -->
  <link rel="stylesheet" href="../../../../css/syntax.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>
<style>

  header.intro-header {
        background-image: url('http://ww1.sinaimg.cn/thumbnail/68ba9367ly1fo8dpfo3kmj22gj2gj4qp.jpg')
    }
</style>
<!-- hack iOS CSS :active style -->

<body ontouchstart="" class="animated fadeIn">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- Navigation -->
  <nav class="navbar navbar-default navbar-custom navbar-fixed-top " id="nav-top" data-ispost="true" data-istags="false
" data-ishome="false">
    <div class="container-fluid">
      <!-- Brand and toggle get grouped for better mobile display -->
      <div class="navbar-header page-scroll">
        <button type="button" class="navbar-toggle">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand animated pulse" href="/">
          <span class="brand-logo">
            Hayden
          </span>
          's Blog
        </a>
      </div>

      <!-- Collect the nav links, forms, and other content for toggling -->
      <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
      <!-- /.navbar-collapse -->
      <div id="huxblog_navbar">
        <div class="navbar-collapse">
          <ul class="nav navbar-nav navbar-right">
            <li>
              <a href="/">Home</a>
            </li>




            <li>
              <a href="/tags/">TAGS</a>
            </li>





            <li>
              <a href="/about/">ABOUT</a>
            </li>





          </ul>
        </div>
      </div>
    </div>
    <!-- /.container -->
  </nav>
  <script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    //    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)

    function handleMagic(e) {
      if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
        $navbar.className = " ";
        // wait until animation end.
        setTimeout(function() {
          // prevent frequently toggle
          if ($navbar.className.indexOf('in') < 0) {
            $collapse.style.height = "0px"
          }
        }, 400)
      } else {
        // OPEN
        $collapse.style.height = "auto"
        $navbar.className += " in";
      }
    }
  </script>
  <!-- Main Content -->
  <!--only post-->


  <img class="wechat-title-img" src="/images/title_img/global_network.png">


  <style>
    header.intro-header {
    background-image: url('/images/title_img/global_network.png?imageView2/1/w/1400/h/400/interlace/1/q/90')
  }
</style>

  <header class="intro-header">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
          <div class="post-heading">
            <h1>TCP/IP 协议栈概述</h1>

            <h2 class="subheading">TCP/IP 逐层功能简述</h2>

            <span class="meta">
              作者 Hayden Wang
              <span>
                日期 2018-02-21
              </span>
            </span>
            <div class="tags text-center">

              <a class="tag" href="/tags/#Networks" title="Networks">Networks</a>

            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="post-title-haojen">
      <span>
        TCP/IP 协议栈概述
      </span>
    </div>
  </header>

  <!-- Post Content -->
  <article>
    <div class="container">
      <div class="row">
        <!-- Post Container -->
        <div class="col-lg-8 col-lg-offset-1 col-sm-9 post-container">
          <p>摘要<br><a id="more"></a>
          </p>
          <h2 id="1-计算机网络概述"><a href="#1-计算机网络概述" class="headerlink" title="1. 计算机网络概述"></a>1. 计算机网络概述</h2>
          <h3 id="1-1-计算机与网络发展的7个阶段"><a href="#1-1-计算机与网络发展的7个阶段" class="headerlink" title="1.1 计算机与网络发展的7个阶段"></a>1.1 计算机与网络发展的7个阶段</h3>
          <ol>
            <li>批处理时代 (1950s)：实现奖用户程序和数据装入卡带或磁带，并由计算机按照一定的顺序读取，使用户所要执行的程序和数据能够一并批量得到处理的方式。</li>
            <li>分时系统时代 (1960s)：多个终端与同一计算机连接，允许多个用户同时使用一台计算机。分时系统中每个终端与计算机之间使用通信线路连接形成一个星形结构。从这一时期开始，网络与计算机之间的关系开始逐渐浮出水面。</li>
            <li>计算机间通信时代 (1970s)：计算机间的通信显著提高了计算机的可用性，人们开始使用多台计算机分布式处理，最终一并得到返回结果。</li>
            <li>计算机网络时代 (1980s)：70年代初期，人们开始试验机与分组交换技术的计算机网络。80年代，能够互连多种计算机的网路诞生。</li>
            <li>互联网的普及时代 (1990s)：通过连接不同厂商的计算机建立一个成本更低的网路环境，实现异构计算机的通信。</li>
            <li>以互联网为中心的时代 (2000s)：互联网对通信领域产生巨大影响，许多发展道路个不相同的网络技术也向互联网靠拢。</li>
            <li>一切皆TCP/IP的网路时代 (2010s)：最初，人们更关注单纯的连接性，以不受任何限制地建立互联网连接为最终目的。而现在人们不再满足于单纯建立连接，而是追求安全建立连接的目标。</li>
          </ol>
          <h3 id="1-2-传输方式分类"><a href="#1-2-传输方式分类" class="headerlink" title="1.2 传输方式分类"></a>1.2 传输方式分类</h3>
          <p><strong>面向有连接 vs 面向无连接</strong></p>
          <ul>
            <li>面向有连接型：发送数据之前需要收发主机之间建立一条通信线路。</li>
            <li>面向无连接型：不要求建立断开连接，发送方可以在任何时间发送。</li>
          </ul>
          <p><strong>电路交换 vs 分组交换</strong></p>
          <ul>
            <li>电路交换：建立好连接之后，一直使用这个线路直到断开为止。电路交换中传输速度不变。</li>
            <li>分组交换：数据分成多个包，按一定顺序分别发送。发送方将数据发分组给路由器，路由器缓存之后再发出去，所以又叫积蓄交换。分组交换中速度不定，还可能由于路由器问题出现数据丢失、无法发送的情况。</li>
          </ul>
          <p><strong>根据接收端数量分类</strong></p>
          <ul>
            <li>单播 (Unicast)：一对一的通信。例：固定电话。</li>
            <li>广播 (Broadcast)：广播域之内的计算机都收到广播消息。例：电视信号。</li>
            <li>多播 (Multicast)：发给一组限定的主机。例：电视会议。</li>
            <li>任播 (Anycast)：选择一台最符合网络条件的主机，之后单播通信。例：DNS。</li>
          </ul>
          <h3 id="1-3-网络硬件"><a href="#1-3-网络硬件" class="headerlink" title="1.3 网络硬件"></a>1.3 网络硬件</h3>
          <ol>
            <li>网卡 (Network Interface)：<ul>
                <li>使计算机连网的设备</li>
                <li>网络接口卡 (NIC, Network Information Center)，也叫网络适配器，网卡，LAN卡。</li>
              </ul>
            </li>
            <li>中继器 (Repeater): <ul>
                <li>从物理层上延长网络的设备</li>
                <li>通过中继器不能无限延长。</li>
              </ul>
            </li>
            <li>网桥 (Bridge) / 2层交换机：<ul>
                <li>从数据链路层上延长网络的设备</li>
                <li>网桥没有连接段个数的限制。自学式网桥能够记住转发过的MAC地址，存入自己的内存中。</li>
              </ul>
            </li>
            <li>路由器 (Router) / 3层交换机：<ul>
                <li>通过网络层转发分组数据的设备</li>
                <li>网络层面上连接两个网络，并对分组报文进行转发的设备。路由器可以连接不同的数据链路层。</li>
              </ul>
            </li>
            <li>4-7层交换机<ul>
                <li>处理传输层以上各层网络传输的设备</li>
                <li>信息传输层及以上的数据，进行特定处理，如负载均衡器。</li>
              </ul>
            </li>
            <li>网关 (Gateway) <ul>
                <li>转换协议的设备</li>
                <li>负责从传输层到应用层的数据进行转换和转发的设备。代理服务器也是网关的一种。</li>
              </ul>
            </li>
          </ol>
          <hr>
          <h2 id="2-网络参考模型"><a href="#2-网络参考模型" class="headerlink" title="2. 网络参考模型"></a>2. 网络参考模型</h2>
          <p>协议是计算机之间通过网络实现通信时实现达成的一种约定。异构的计算机之间只要支持相同的协议，并遵循相同协议进行处理，就能实现相互通信。</p>
          <p>OSI (Open System Interconnection) 是ISO制定的通信系统国际标准，虽然没有得到普及，但是OSI参考模型常被用于网络协议的制定当中。协议标准化推动了计算机网络的普及。</p>
          <h3 id="2-1-协议的分层"><a href="#2-1-协议的分层" class="headerlink" title="2.1 协议的分层"></a>2.1 协议的分层</h3>
          <ul>
            <li>模型：在OSI模型中，每个分层都接受下一层提供的服务，并为上一层提供服务。上下层之间交互时遵循“接口”，同一层间交互时遵循“协议”。</li>
            <li>分层的优势：没个分层独立使用，即使系统中分层发生变化也不会波及整个系统。因此扩展性和灵活性较强。</li>
            <li>分层的劣势：过分模块化，使处理变得更加沉重以及没个模块都不得不实现相似的处理逻辑等问题。</li>
          </ul>
          <h3 id="2-2-OSI参考模型"><a href="#2-2-OSI参考模型" class="headerlink" title="2.2 OSI参考模型"></a>2.2 OSI参考模型</h3>
          <ul>
            <li>应用层：为应用程序提供服务并规定应用程序中通信的关键细节。</li>
            <li>表示层：负责数据格式的转换，将设备固有的数据格式转换为网路标准传输格式。</li>
            <li>会话层：负责建立、断开通信连接（数据流动的逻辑通路），负责连接的时机。</li>
            <li>传输层：起可靠通信的作用。只在通信双方节点上处理，无需在路由器上处理，负责建立实际的连接。</li>
            <li>网络层：在网络与网络相互连接的环境中，将数据传输到目标地址。主要负责寻址和路由选择。</li>
            <li>数据链路层：负责物理层面上互连的、节点之间的通信传输。</li>
            <li>物理层：负责01比特流与电压高低，灯光闪灭之间的转换。</li>
          </ul>
          <p><img src="/images/tcp_ip/osi_layers.png" alt="OSI七层模型"><br><img src="/images/tcp_ip/osi_layers_2.png" alt="OSI七层模型"></p>
          <h3 id="2-3-TCP-IP"><a href="#2-3-TCP-IP" class="headerlink" title="2.3 TCP / IP"></a>2.3 TCP / IP</h3>
          <p>是利用IP进行通信时所必需用到的协议的总称。</p>
          <p><img src="/images/tcp_ip/tcpip_layers.png" alt="TCP/IP参考模型"></p>
          <h3 id="2-4-分层中包的结构"><a href="#2-4-分层中包的结构" class="headerlink" title="2.4 分层中包的结构"></a>2.4 分层中包的结构</h3>
          <p><img src="/images/tcp_ip/package_structure.png" alt="分层中包的结构"></p>
          <hr>
          <h2 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3. 数据链路层"></a>3. 数据链路层</h2>
          <p>数据链路可以视为网络传输中的最小单位。</p>
          <p>数据链路层协议定义了通过通信媒介互连的设备之间传输的规范。<br>相互直连的设备之间使用实际地址实现传输。MAC地址实际上是为了识别同一传输介质上的设备</p>
          <p><strong>主要作用</strong>：在互连的同一种数据链路的节点之间进行包传递（跨越数据链路要借助网络层）。</p>
          <h3 id="3-1-MAC地址"><a href="#3-1-MAC地址" class="headerlink" title="3.1 MAC地址"></a>3.1 MAC地址</h3>
          <p>MAC地址用于识别同一数据链路中不同计算机的识别码。</p>
          <ul>
            <li>第1位：单播地址(0) / 多播地址(1)</li>
            <li>第2位：全局地址(0) / 本地地址(1)</li>
            <li>第3-24位：厂商识别码，IEEE管理</li>
            <li>第25-48位：产品识别码，厂商管理</li>
          </ul>
          <p><strong>根据MAC地址转发</strong>：以太网交换机就是持有多个端口的网桥。它根据数据链路层每个帧的MAC地址，决定从哪个端口发送数据。所参考的、用以记录发送接口的表叫做转发表 (Flrwarding Table)。<br>交换机可以通过自学维护转发表：</p>
          <p><img src="/images/tcp_ip/mac_forward.png" alt="依据MAC地址的转发过程"></p>
          <p>MAC地址没有层次性，所以转发表中入口的个数与整个网络中所有网络设备数量有关。设备数量增加，转发表增大，转发时间增常。</p>
          <p>（采用VLAN技术的网桥，可以直接修改网络结构而不用实际修改网络布线）</p>
          <h3 id="3-2-共享介质网络-vs-非共享介质网络"><a href="#3-2-共享介质网络-vs-非共享介质网络" class="headerlink" title="3.2 共享介质网络 vs 非共享介质网络"></a>3.2 共享介质网络 vs 非共享介质网络</h3>
          <p><strong>共享介质网络：由多个设备共享一个通信介质的网路。</strong></p>
          <ul>
            <li><strong>争用方式</strong>：争夺获取数据传输的权利，也叫CSMA (载波监听多路访问)。CSMA/CD：如果检测到冲突，释放信道并等待一段时间后，重新争用介质。</li>
            <li><strong>令牌传递方式</strong>：沿着令牌环发送一种叫“令牌”的特殊报文，只有获得令牌才能发送数据。特点：(1) 不会有冲突；(2)每个站机会均等。所以网络拥堵也不会使性能下降。</li>
          </ul>
          <p><strong>非共享介质网络：通过以太网交换机构建网路，从而使计算机与接口之间形成一对一的连接，即可实现全双工通信。</strong></p>
          <hr>
          <h2 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4. 网络层"></a>4. 网络层</h2>
          <p><strong>主要作用</strong>：实现终端节点之间的通信。这种终端节点之间的通信也叫“点对点 (point-to-point)通信”。<br><strong>IP</strong>：IP也是分组交换的一种协议，但是不具有重发机制，属于不可靠协议。<br><strong>ICMP</strong>：IP数据包再发送途中一旦发生异常导致无法到达，给发送方一个通知。ICMP也被用来诊断网络健康状况。</p>
          <h3 id="4-1-IP基础知识"><a href="#4-1-IP基础知识" class="headerlink" title="4.1 IP基础知识"></a>4.1 IP基础知识</h3>
          <p><strong>IP大致分为三大作用模块：IP寻址，路由 (最终节点为止的转发)，IP分包与组包。</strong></p>
          <ul>
            <li><strong>IP地址</strong>：IP地址用于在连接到网络中的所有主机中识别出进行通信的目标地址。</li>
            <li><strong>路由控制</strong>：当某个IP包到达路由器时，路由器首先查出其目标地址，再决定下一步将这个包法网哪个路由器。过程反复多次，直到找到目标地址将数据包发给这个节点。为了将数据包发给目标主机，所有主机维护一张路由表 (Routing Table)，该表记录IP数据下一步应该发给哪个路由器。</li>
            <li><strong>IP分片</strong>：IP是实现多个链路之间通信的协议，不同的链路各自的最大传输单位 (MTU: Maximum Transmission Unit) 不同。为了解决这个问题，IP进行分片 (IP Fragmentation) 处理，将较大的IP包分成多个较小的IP包。</li>
            <li><strong>面向无连接</strong>：IP面向无连接，在发包之前，不需要建立与对端目标之间的连接。原因：(1)简化；(2)提速。IP提供尽力服务，并不做最终收到验证。IP包在传输过程中可能出现丢包、错位、数据量翻倍等问题。</li>
          </ul>
          <h3 id="4-2-IP地址"><a href="#4-2-IP地址" class="headerlink" title="4.2 IP地址"></a>4.2 IP地址</h3>
          <p>IP地址由网络标识和主机标识组成：</p>
          <ul>
            <li>网络标识在数据链路的每个段配置不同的值，必须保证相互连接的每个段地址不重复。</li>
            <li>主机标识在同一网段内不重复出现，保证同一网段内的唯一性。</li>
          </ul>
          <p>网络标识和主机标识划分有两种类型：最初用分类，现在用子网掩码。</p>
          <p><strong>IP地址的分类</strong>：</p>
          <ul>
            <li>A类地址：开头为0，第2-8位为网络标识；</li>
            <li>B类地址：开头为10，第3-16位为网络标识；</li>
            <li>C类地址：开头为110，第4-24位为网络标识；</li>
            <li>D类地址：开头为1110，第5-32位为网络标识，没有主机标识，常用于多播。</li>
            <li>注意：主机地址不能全为0或1。0表示对应的网路地址或IP地址不可获知，全部为1用作广播。</li>
          </ul>
          <p><strong>子网掩码</strong>：<br>子网掩码分出比ABC更小粒度的网路。子网掩码用32位二进制表示，对应网络标识全为1，对应主机标识全为0。另外可以用十进制表示网络地址的位数。如172.20.100.52 /26。</p>
          <h3 id="4-3-路由控制"><a href="#4-3-路由控制" class="headerlink" title="4.3 路由控制"></a>4.3 路由控制</h3>
          <p>路由控制表的形成方式有两种：</p>
          <ol>
            <li>静态路由控制：管理员手动设置。</li>
            <li>动态路由控制：路由器与其他路由器相互交换信息时自动刷新。动态路由会给相邻路由器发送自己已知的网路连接信息，而这些信息又像接力一样依次传递给其他路由器，直至整个网络都了解时，路由控制表就制作完成了。此时就能正确转发IP数据包了。</li>
          </ol>
          <p><strong>IP地址的网路地址部分用于进行路由控制</strong>。路由控制表中记录着下一步应该发送至路由器的地址，如果有多条记录吻合，选择最长匹配。</p>
          <h3 id="4-4-IP分包与组包"><a href="#4-4-IP分包与组包" class="headerlink" title="4.4 IP分包与组包"></a>4.4 IP分包与组包</h3>
          <p><strong>IP报文的分片与重组</strong></p>
          <ul>
            <li>分片：分片往往在网路上遇到比较大的报文无法一下子发送出去时才进行处理。</li>
            <li>重组：经过分片的数据包在重组的时候，只能由目标主机进行，路由器虽然做分片，但是不会重组。</li>
          </ul>
          <p><strong>分片机制的不足</strong></p>
          <ol>
            <li>路由器的处理负荷加重；</li>
            <li>分片处理中，某个分片丢失，整个数据包作废。</li>
          </ol>
          <p><strong>路径MTU发现</strong></p>
          <p><strong>工作原理</strong>：</p>
          <ol>
            <li>首先在发送端主机发送IP数据报时将首部分片禁止标志位设为1；</li>
            <li>通过一个ICMP的不可达消息将链路上MTU返回给主机；</li>
            <li>设置当前MTU，继续发送；</li>
            <li>直到不再收到ICMP，就将最后一次MTU设为当前MTU。</li>
          </ol>
          <p><strong>UDP下的MTU发现机制</strong>：</p>
          <ol>
            <li>IP首部设置部分片，路由器丢包；</li>
            <li>ICMP通知下一次MTU；</li>
            <li>UDP没有重发处理，下一个消息将分片。UDP数据报被IP分片，不区分UDP首部或数据；</li>
            <li>在目标主机重组，再传给UDP层。</li>
          </ol>
          <p><img src="/images/tcp_ip/udp_mtu.png" alt="UDP下的MTU过程"></p>
          <p><strong>TCP下的MTU发现机制</strong></p>
          <ol>
            <li>IP首部设置部分片，路由器丢包；</li>
            <li>ICMP通知下一次MTU；</li>
            <li>TCP重发处理。TCP负责将数据分成IP层不会再分的粒度之后再传，故IP层不做分片处理；</li>
            <li>不需要重组，数据被原样发给接收端TCP层。</li>
          </ol>
          <p><img src="/images/tcp_ip/tcp_mtu.png" alt="TCP下的MTU过程"></p>
          <h3 id="4-5-IPv4首部"><a href="#4-5-IPv4首部" class="headerlink" title="4.5 IPv4首部"></a>4.5 IPv4首部</h3>
          <p><img src="/images/tcp_ip/ipv4_header.png" alt="IPv4包首部结构"></p>
          <ul>
            <li><strong>总长度</strong>：IP首部与数据部分合起来的总字节数。字段长16比特，因此IP包最大长度为65535字节。</li>
            <li><strong>生存时间</strong>：由8比特构成，实际中指最多中转多少个路由器，每次递减1，减为0则丢弃。</li>
            <li><strong>首部校验和</strong>：只校验数据报的首部，不校验数据部分。</li>
          </ul>
          <h3 id="4-6-IP相关协议与技术"><a href="#4-6-IP相关协议与技术" class="headerlink" title="4.6 IP相关协议与技术"></a>4.6 IP相关协议与技术</h3>
          <h4 id="1-DNS-Domain-Name-Service"><a href="#1-DNS-Domain-Name-Service" class="headerlink" title="1. DNS: Domain Name Service"></a>1. DNS: Domain Name Service</h4>
          <p>IP地址不便记忆，DNS管理主机名和IP地址的对应关系。</p>
          <p><strong>DNS查询过程</strong>：</p>
          <ul>
            <li>解析器为了调查IP地址，向域名服务器进行查询处理；</li>
            <li>接受这个查询请求的域名服务器首先在自己的数据库中进行查找，如果有域名对应的IP地址就返回，如果没有则再向上一级进行查询；</li>
            <li>直到从根开始进行遍历，直到找到指定的域名服务器，并返回想要的数据；</li>
            <li>解析器和域名服务器将最新的信息暂存到缓存里，减少每次查询时的性能消耗。</li>
          </ul>
          <p>DNS服务器是一个分布式数据库。<br>从IP地址检索主机名称信息的叫PTR。</p>
          <h4 id="2-ARP-Address-Resolution-Protocol"><a href="#2-ARP-Address-Resolution-Protocol" class="headerlink" title="2. ARP: Address Resolution Protocol"></a>2. ARP: Address Resolution Protocol</h4>
          <p>只要确定了IP地址，就能够向目标地址发送IP数据报，然而在数据链路层却有必要了解IP对应的MAC地址。<br>ARP是解决地址问题的协议，以目标IP为线索，定位下一个用来接收数据分包的网络设备对应的MAC地址。</p>
          <p><strong>ARP工作机制</strong>：</p>
          <ul>
            <li>ARP是借助ARP请求与ARP响应两种类型的包确定MAC地址的。</li>
            <li>起初通过要广播一个ARP请求包。</li>
            <li>收到请求包的每个主机检查如果ARP请求包的目标IP与自己是否一致，一致则将自己的MAC塞进ARP响应包中返回到IP地址。<br>为什么IP地址和MAC地址缺一不可：MAC不具有层次性，仅凭MAC地址不能确定这台机器所处的位置；如果全世界设备用MAC相连，那么网桥在习得之前要向全世界发送包（自学式网桥）。</li>
          </ul>
          <blockquote>
            <p><strong>RARP (Reversed Address Resolution Protocol)</strong>：从MAC地址定位IP地址的协议。</p>
          </blockquote>
          <h4 id="3-ICMP-Internet-Control-Message-Protocol"><a href="#3-ICMP-Internet-Control-Message-Protocol" class="headerlink" title="3. ICMP: Internet Control Message Protocol"></a>3. ICMP: Internet Control Message Protocol</h4>
          <p><strong>主要功能</strong>：确认IP包是否成功到达目标地址，通知在发送过程中IP包被废弃的具体原因，改善网络设置等。<br>ICMP通知会通过IP发送。ICMP消息大致分为：通知出错原因的错误消息，用于诊断的查询消息。</p>
          <p><strong>主要的ICMP消息</strong>：</p>
          <ul>
            <li><strong>ICMP目标不可达消息</strong>：IP路由器无法将数据报发送至目标主机时，会给发送端返回一个不可达ICMP，说明不可达具体原因。</li>
            <li><strong>ICMP重定向消息</strong>：路由器发现发送端主机使用了次优路径，返回一个ICMP重定向消息，包含最合适的路由信息和源数据。</li>
            <li><strong>ICMP超时消息</strong>：当IP数据包的TTL减为0时，发回一个ICMP超时消息，通知该包被丢弃。(traceroute)</li>
            <li><strong>ICMP回送消息</strong>：用于进行通信的主机或路由器之间，判断数据包是否成功到达。(ping)</li>
          </ul>
          <h4 id="4-DHCP-Dynamic-Host-Configuration-Protocol"><a href="#4-DHCP-Dynamic-Host-Configuration-Protocol" class="headerlink" title="4. DHCP: Dynamic Host Configuration Protocol"></a>4. DHCP: Dynamic Host Configuration Protocol</h4>
          <p><strong>主要目的</strong>：移动设备多，设置IP地址繁琐。为了实现自动设置IP地址、统一管理IP地址分配。有了DHCP，计算机只要连接到网络就能进行TCP/IP通信。</p>
          <p><strong>DHCP工作机制</strong>：</p>
          <ul>
            <li>DHCP服务器：再分配IP地址前发送ICMP回送请求包，确认没有返回应答。</li>
            <li>DHCP客户端：针对从DHCP分配的IP地址发送ARP请求包，确认没有返回应答。</li>
          </ul>
          <h4 id="5-NAT-Network-Address-Translator"><a href="#5-NAT-Network-Address-Translator" class="headerlink" title="5. NAT: Network Address Translator"></a>5. NAT: Network Address Translator</h4>
          <p>NAT是用于在本地网络中使用私有地址，在连接互联网时转而使用全局IP地址的技术。<br>私有IP地址最初没有计划连接互联网，能够互换私有IP和全局IP的NAT技术出现后，配有私有地址的主机与配有全局地址的互联网主机实现了通信。目前私有IP地址结合NAT成为解决IP地址分配问题的主流方案。</p>
          <hr>
          <h2 id="5-传输层"><a href="#5-传输层" class="headerlink" title="5. 传输层"></a>5. 传输层</h2>
          <p><strong>传输层以端口号为识别码</strong>。端口号用于识别同一台计算机中进行通信的不同应用程序。也被称为程序地址。<br>TCP/IP常用5个信息识别一个通信：源IP地址、目标IP地址、传输协议号、源端口号、目标端口号。</p>
          <h3 id="5-1-两种传输层协议的对比"><a href="#5-1-两种传输层协议的对比" class="headerlink" title="5.1 两种传输层协议的对比"></a>5.1 两种传输层协议的对比</h3>
          <p><strong>TCP是面向连接的、可靠的流协议</strong>。流是指不间断的数据结构。TCP提供可靠性传输，实行顺序控制或重发控制机制，此外还具备流量控制、拥塞控制、提高网络利用率等众多功能。TCP用于在传输层有必要实现可靠传输的情况。</p>
          <p><strong>UDP是不具有可靠性的数据报协议</strong>。细微的处理它回交给上层的应用去完成。在UDP的情况下，虽然可以确保发送消息的大小，却不能保证数据一定能到达。UDP主要用于哪些对高速传输和实时性要求较高的通信或广播通信。</p>
          <h3 id="5-2-UDP（面向无连接、不可靠协议）"><a href="#5-2-UDP（面向无连接、不可靠协议）" class="headerlink" title="5.2 UDP（面向无连接、不可靠协议）"></a>5.2 UDP（面向无连接、不可靠协议）</h3>
          <p>User Datagram Protocol</p>
          <p>UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。<br>即使出现网络拥堵的情况下，UDP也无法进行流量控制等避免网络拥塞的行为。此外，传输途中即使出现丢包，UDP也不负责重发。甚至当出现包的到达顺序乱掉时也没有纠正的功能。<br>UDP将部分控制转移给应用程序处理。</p>
          <p><strong>UDP首部</strong><br><img src="/images/tcp_ip/udp_header.png" alt="UDP首部"></p>
          <p>由于UDP面向无连接，可以随时发送数据。再加上UDP本身处理既简单又高效，因此经常用于：</p>
          <ul>
            <li>包总量较少的通信（DNS、SMTP）等</li>
            <li>视频、音频等多媒体通信（即时通信）</li>
            <li>限定于LAN等特定网络的应用通信</li>
            <li>广播通信（广播、多播）</li>
          </ul>
          <h3 id="5-3-TCP（面向有连接、可靠协议）"><a href="#5-3-TCP（面向有连接、可靠协议）" class="headerlink" title="5.3 TCP（面向有连接、可靠协议）"></a>5.3 TCP（面向有连接、可靠协议）</h3>
          <p>Transmission Control Protocol</p>
          <p>TCP作为面向有连接的协议，只有在确定对端存在时才能发送数据，从而可以控制通信流量的浪费。<br><strong><em>TCP通过校验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输</em></strong>。</p>
          <p><strong>TCP首部</strong><br><img src="/images/tcp_ip/tcp_header.png" alt="TCP首部"></p>
          <h4 id="1-序列号与确认应答"><a href="#1-序列号与确认应答" class="headerlink" title="1. 序列号与确认应答"></a>1. 序列号与确认应答</h4>
          <ul>
            <li>ACK：在TCP中，当发送的数据到达主机时，接收端主机返回一个已收到消息的通知。这个消息叫做确认应答 (ACK)。TCP通过ACK实现可靠的数据传输，如果没有收到确认应答，数据丢失可能性很大 (也有可能时ACK丢失)。</li>
            <li>SYN：确认应答处理、重发控制、重复控制等功能都可以通过序列号实现。接收端查询接受数据TCP首部中的序列号和数据长度，将自己下一步应该接收的序列号作为确认应答返回回去。</li>
          </ul>
          <h4 id="2-重发超时"><a href="#2-重发超时" class="headerlink" title="2. 重发超时"></a>2. 重发超时</h4>
          <ul>
            <li>重发超时是指在重发数据之前，等待确认应答到来的时间间隔。</li>
            <li>TCP要求不论在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。为此在每次发包时都会计算往返时间 (RTT, Round Trip Time) 及其偏差 (jitter)，重发超时就是比RTT+jitter稍大一点的值。</li>
            <li>数据重发之后还是收不到确认应答，就在此发送，重发超时以2、4、8倍指数增长。</li>
            <li>数据不会被无限重发，达到一定重发次数之后，就判断为网络或对端主机异常，强制关闭连接。</li>
          </ul>
          <h4 id="3-连接管理"><a href="#3-连接管理" class="headerlink" title="3. 连接管理"></a>3. 连接管理</h4>
          <ul>
            <li>三次握手：在数据通信之前，通过TCP首部发送一个SYN包作为建立连接的请求等待确认应答。如果对方收到确认应答，则认为可以进行数据通信。如果对端确认应答未能到达，就不会进行数据通信。</li>
            <li>四次挥手：通信结束时进行断开连接的处理 (FIN包)。</li>
          </ul>
          <p><img src="/images/tcp_ip/tcp_conn.png" alt="TCP连接管理"></p>
          <p>建立TCP连接的同时，也可以确定发送数据包的单位，称为最大消息长度 (MSS: Maximum Segment Size)。理想情况是MSS正好是IP中不会被分片处理的最大数据长度。<strong>MSS是在三次握手的时候，在两端主机之间被计算得出</strong>。</p>
          <h4 id="4-窗口控制提高速度"><a href="#4-窗口控制提高速度" class="headerlink" title="4. 窗口控制提高速度"></a>4. 窗口控制提高速度</h4>
          <p>TCP以一个段为单位，每发一个段进行一次确认应答的处理。缺点是包往返时间越长通信性能越低。<br>TCP采用窗口解决此问题。发送端主机在发送一个段后不用等待确认应答，而是继续发送。<br><strong>窗口大小就是无需等待确认应答而刻意继续发送数据的最大值</strong>。</p>
          <p><img src="/images/tcp_ip/tcp_window_1.png" alt="TCP窗口控制"><br><img src="/images/tcp_ip/tcp_window_2.png" alt="TCP窗口控制"></p>
          <h4 id="5-窗口控制-重发控制"><a href="#5-窗口控制-重发控制" class="headerlink" title="5. 窗口控制 + 重发控制"></a>5. 窗口控制 + 重发控制</h4>
          <p><strong>确认应答未能返回的情况</strong>：<br>当窗口在一定程度上较大时，即使有少部分确认应答丢失也不会进行数据重发，可以通过下一个确认应答进行确认。</p>
          <p><img src="/images/tcp_ip/tep_retransmit_1.png" alt="TCP窗口控制"></p>
          <p><strong>某个报文段丢失的情况</strong>：<br>高速重发控制：接收端没有收到自己期望的序列号时，会对之前收到的数据进行重复的确认应答。发送端连续收到三次同样的确认应答，就认为数据已丢失，需要进行重发。这个机制相比超时机制可以提供快速的重发服务。</p>
          <p><img src="/images/tcp_ip/tep_retransmit_2.png" alt="TCP窗口控制"></p>
          <h4 id="6-流量控制"><a href="#6-流量控制" class="headerlink" title="6. 流量控制"></a>6. 流量控制</h4>
          <ul>
            <li><strong>解决的问题</strong>：接收端忙，无法处理发送的数据，结果触发重传，浪费网络流量。</li>
            <li><strong>概念</strong>：TCP流量控制可以根据接收端实际接受能力来控制发送的数据量。</li>
            <li><strong>具体操作</strong>：接收端向发送端通知自己可以接收的数据大小，于是发送端会发送不超过这个限度的数据。这个限度成为窗口大小。TCP首部专门有一个字段通知窗口大小。接收端的缓冲区一单面临溢出，就通知发送端缩减窗口大小。</li>
          </ul>
          <p><img src="/images/tcp_ip/tcp_traffic_control.png" alt="TCP流量控制"></p>
          <p>为了避免窗口更新的通知丢失，发送端会主动发送窗口探测。</p>
          <h4 id="7-拥塞控制"><a href="#7-拥塞控制" class="headerlink" title="7. 拥塞控制"></a>7. 拥塞控制</h4>
          <ul>
            <li><strong>问题</strong>：在网络拥堵时，发送大的数据会导致网络瘫痪。</li>
            <li><strong>解决</strong>：TCP在通信开始时用慢启动算法对数据量进行控制。</li>
            <li><strong>步骤</strong>：为了在发送端调节所需要发送数据的量，定义了一个“拥塞窗口”，慢启动的时候设为1MSS，之后每收到一次ACK，拥塞窗口就加1。发送时，将拥塞窗口与接收端通知的窗口大小做比较，取较小的作为窗口大小。</li>
          </ul>
          <p><img src="/images/tcp_ip/tcp_congestion_control_1.png" alt="TCP拥塞控制"></p>
          <ul>
            <li>由于拥塞窗口会以指数增长，所以超过一个阈值之后，再收到ACK，只会以线性比例增大窗口。公式为：数据段字节数^2/拥塞窗口字节数。</li>
            <li>TCP开启时，并没有设置慢启动阈值，只有在超时重发时，将阈值设为当时拥塞窗口的一半大小。</li>
            <li>收到重复确认应答时，慢启动阈值设为当时窗口大小一半，再将窗口大小设为阈值+3。</li>
          </ul>
          <p><img src="/images/tcp_ip/tcp_congestion_control_2.png" alt="TCP拥塞控制"></p>
          <hr>
          <h2 id="6-应用层"><a href="#6-应用层" class="headerlink" title="6. 应用层"></a>6. 应用层</h2>
          <h3 id="6-1-远程登录"><a href="#6-1-远程登录" class="headerlink" title="6.1 远程登录"></a>6.1 远程登录</h3>
          <p>实现从自己本地计算机登录到网络另一端计算功能的应用就叫做远程登录。远程登录主要使用TELNET和SSH两种协议。</p>
          <ul>
            <li>
              <p><strong>TELNET</strong>：TELNET利用TCP的一条连接，通过一条连接向主机发送文字命令并在主机上执行。本地用户好像直接与远程主机内部的Shell相连，直接在本地进行操作。</p>
            </li>
            <li>
              <p><strong>SSH</strong>：SSH是加密的远程登录系统。TELNET中登录时无需输入密码就可以发送，容易造成通信窃听和非法入侵的危险。使用SSH后可以加密通信内容，即使信息被窃听也无法破解所发送的密码、具体命令以及命令返回的结果。</p>
            </li>
          </ul>
          <h3 id="6-2-文件传输"><a href="#6-2-文件传输" class="headerlink" title="6.2 文件传输"></a>6.2 文件传输</h3>
          <p>FTP是在两个相连的计算机之间进行文件传输时使用的协议。</p>
          <p>FTP的工作机制：</p>
          <ul>
            <li>使用两条TCP连接：一条用来控制，另一条用于数据 (文件) 的传输。</li>
            <li>用于控制的TCP连接主要在FTP控制部分使用，例如登录用户名和密码的验证、发送文件的名称、发送方式的设置。在用户断开之前会一直保持连接状态。</li>
            <li>用于数据传输的TCP连接是按照与控制连接相反的方向建立的。</li>
          </ul>
          <h3 id="6-3-电子邮件"><a href="#6-3-电子邮件" class="headerlink" title="6.3 电子邮件"></a>6.3 电子邮件</h3>
          <ul>
            <li><strong>SMTP (Simple Mail Transfer Protocol)</strong>：发送电子邮件的协议，不具有验证发送者的功能。</li>
            <li><strong>MIME (Multipurpose Internet Mail Extensions)</strong>：规定了应用消息的格式，扩展了电子邮件数据类型。</li>
            <li><strong>POP (Post Office Protocol)</strong>：用于接收电子邮件的协议，发送端的邮件根据SMTP协议将被转发给一直开启的POP服务器，客户端再根据POP协议从POP服务器接收邮件。这个过程中要进行用户验证。</li>
            <li><strong>IMAP (Internet Message Access Protocol)</strong>：接收邮件的协议。在POP中邮件由客户端管理，而IMAP中邮件由服务器管理，这样可以通过多种终端连接IMAP服务器来收发邮件。</li>
          </ul>
          <h3 id="6-4-万维网"><a href="#6-4-万维网" class="headerlink" title="6.4 万维网"></a>6.4 万维网</h3>
          <p>万维网 (World Wide Web) 是将互联网中的信息以超文本形式展现的系统。WWW定义了3个重要的概念：访问信息的手段与位置 (URI)、信息表现形式 (HTML)、信息转发 (HTTP)。</p>
          <ul>
            <li><strong>URI (Uniform Resource Identifier)</strong>：用于标识资源。URL常被用来表示互联网中资源的具体位置，但是URI不限于标识互联网资源，它可以用作所有资源的识别码。</li>
            <li><strong>HTML (HyperText Markup Language)</strong>：记述Web页的一种语言。WWW通用的数据表现协议。</li>
            <li><strong>XML (Extensible Markup Language)</strong>：WWW中数据存入文件或在应用间进行交互经常使用XML。</li>
            <li><strong>HTTP (HyperText Transfer Protocol)</strong>：客户端向服务器80端口建立一个连接，然后在这个连接上进行请求和应答以及数据报文的发送。HTTP有两个版本HTTP1.0和HTTP1.1。1.0中每个命令和应答都出发一次TCP连接建立与断开。1.1允许在一个TCP上发送多个命令和应答，大幅减少TCP的建立与断开操作，提高了效率。</li>
            <li><strong>JavaScript</strong>：JavaScript是一种嵌入在HTML中的编程语言，作为客户端程序可以运行于多种类型的浏览器中。</li>
            <li><strong>Cookie</strong>：Web服务器用Cookie在客户端保存信息（用户名、登录名等）。</li>
          </ul>
          <hr>
          <h2 id="7-网络安全"><a href="#7-网络安全" class="headerlink" title="7. 网络安全"></a>7. 网络安全</h2>
          <h3 id="7-1-安全协议"><a href="#7-1-安全协议" class="headerlink" title="7.1 安全协议"></a>7.1 安全协议</h3>
          <h4 id="IPsec-amp-VPN"><a href="#IPsec-amp-VPN" class="headerlink" title="IPsec &amp; VPN"></a>IPsec &amp; VPN</h4>
          <p>在互联网上构造一个虚拟的私有网络 (VPN: Virtual Private Network)。互联网中采用加密和认证技术可以达到“即使取到数据也无法读懂”、“检查是否被篡改”等功效。VPN是利用这两种技术打造的网络。</p>
          <h4 id="TLS-SSL-amp-HTTPS"><a href="#TLS-SSL-amp-HTTPS" class="headerlink" title="TLS/SSL &amp; HTTPS"></a>TLS/SSL &amp; HTTPS</h4>
          <p>使用TLS/SSL的HTTP通信叫做HTTPS通信。HTTPS采用对称加密方式，而在发送其公共密码时采用的则是公钥加密方式。<br>确认公钥是够正确主要使用认证中心 (CA) 签发的证书，而主要的认证中心的信息已经嵌入到浏览器的出厂设置中。如果Web浏览器中尚未加入某个认证中心，那么会在页面上提示一个警告信息，此时判断认证中心合法与否由用户自己决定。</p>
          <hr>


          <ul class="pager">

            <li class="previous">
              <a href="/2018/02/21/http-overview/" data-toggle="tooltip" data-placement="top" title="HTTP 协议概述">&larr; Previous Post</a>
            </li>


            <li class="next">
              <a href="/2018/02/20/bit-operation/" data-toggle="tooltip" data-placement="top" title="关于位运算">Next Post &rarr;</a>
            </li>

          </ul>






          <!--加入新的评论系统-->

        </div>

        <div class="hidden-xs col-sm-3 toc-col">
          <div class="toc-wrap">
            <ol class="toc">
              <li class="toc-item toc-level-2"><a class="toc-link" href="#1-计算机网络概述"><span class="toc-text">1. 计算机网络概述</span></a>
                <ol class="toc-child">
                  <li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-计算机与网络发展的7个阶段"><span class="toc-text">1.1 计算机与网络发展的7个阶段</span></a></li>
                  <li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-传输方式分类"><span class="toc-text">1.2 传输方式分类</span></a></li>
                  <li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-网络硬件"><span class="toc-text">1.3 网络硬件</span></a></li>
                </ol>
              </li>
              <li class="toc-item toc-level-2"><a class="toc-link" href="#2-网络参考模型"><span class="toc-text">2. 网络参考模型</span></a>
                <ol class="toc-child">
                  <li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-协议的分层"><span class="toc-text">2.1 协议的分层</span></a></li>
                  <li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-OSI参考模型"><span class="toc-text">2.2 OSI参考模型</span></a></li>
                  <li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-TCP-IP"><span class="toc-text">2.3 TCP / IP</span></a></li>
                  <li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-分层中包的结构"><span class="toc-text">2.4 分层中包的结构</span></a></li>
                </ol>
              </li>
              <li class="toc-item toc-level-2"><a class="toc-link" href="#3-数据链路层"><span class="toc-text">3. 数据链路层</span></a>
                <ol class="toc-child">
                  <li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-MAC地址"><span class="toc-text">3.1 MAC地址</span></a></li>
                  <li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-共享介质网络-vs-非共享介质网络"><span class="toc-text">3.2 共享介质网络 vs 非共享介质网络</span></a></li>
                </ol>
              </li>
              <li class="toc-item toc-level-2"><a class="toc-link" href="#4-网络层"><span class="toc-text">4. 网络层</span></a>
                <ol class="toc-child">
                  <li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-IP基础知识"><span class="toc-text">4.1 IP基础知识</span></a></li>
                  <li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-IP地址"><span class="toc-text">4.2 IP地址</span></a></li>
                  <li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-路由控制"><span class="toc-text">4.3 路由控制</span></a></li>
                  <li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-IP分包与组包"><span class="toc-text">4.4 IP分包与组包</span></a></li>
                  <li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-IPv4首部"><span class="toc-text">4.5 IPv4首部</span></a></li>
                  <li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-IP相关协议与技术"><span class="toc-text">4.6 IP相关协议与技术</span></a>
                    <ol class="toc-child">
                      <li class="toc-item toc-level-4"><a class="toc-link" href="#1-DNS-Domain-Name-Service"><span class="toc-text">1. DNS: Domain Name Service</span></a></li>
                      <li class="toc-item toc-level-4"><a class="toc-link" href="#2-ARP-Address-Resolution-Protocol"><span class="toc-text">2. ARP: Address Resolution Protocol</span></a></li>
                      <li class="toc-item toc-level-4"><a class="toc-link" href="#3-ICMP-Internet-Control-Message-Protocol"><span class="toc-text">3. ICMP: Internet Control Message Protocol</span></a></li>
                      <li class="toc-item toc-level-4"><a class="toc-link" href="#4-DHCP-Dynamic-Host-Configuration-Protocol"><span class="toc-text">4. DHCP: Dynamic Host Configuration Protocol</span></a></li>
                      <li class="toc-item toc-level-4"><a class="toc-link" href="#5-NAT-Network-Address-Translator"><span class="toc-text">5. NAT: Network Address Translator</span></a></li>
                    </ol>
                  </li>
                </ol>
              </li>
              <li class="toc-item toc-level-2"><a class="toc-link" href="#5-传输层"><span class="toc-text">5. 传输层</span></a>
                <ol class="toc-child">
                  <li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-两种传输层协议的对比"><span class="toc-text">5.1 两种传输层协议的对比</span></a></li>
                  <li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-UDP（面向无连接、不可靠协议）"><span class="toc-text">5.2 UDP（面向无连接、不可靠协议）</span></a></li>
                  <li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-TCP（面向有连接、可靠协议）"><span class="toc-text">5.3 TCP（面向有连接、可靠协议）</span></a>
                    <ol class="toc-child">
                      <li class="toc-item toc-level-4"><a class="toc-link" href="#1-序列号与确认应答"><span class="toc-text">1. 序列号与确认应答</span></a></li>
                      <li class="toc-item toc-level-4"><a class="toc-link" href="#2-重发超时"><span class="toc-text">2. 重发超时</span></a></li>
                      <li class="toc-item toc-level-4"><a class="toc-link" href="#3-连接管理"><span class="toc-text">3. 连接管理</span></a></li>
                      <li class="toc-item toc-level-4"><a class="toc-link" href="#4-窗口控制提高速度"><span class="toc-text">4. 窗口控制提高速度</span></a></li>
                      <li class="toc-item toc-level-4"><a class="toc-link" href="#5-窗口控制-重发控制"><span class="toc-text">5. 窗口控制 + 重发控制</span></a></li>
                      <li class="toc-item toc-level-4"><a class="toc-link" href="#6-流量控制"><span class="toc-text">6. 流量控制</span></a></li>
                      <li class="toc-item toc-level-4"><a class="toc-link" href="#7-拥塞控制"><span class="toc-text">7. 拥塞控制</span></a></li>
                    </ol>
                  </li>
                </ol>
              </li>
              <li class="toc-item toc-level-2"><a class="toc-link" href="#6-应用层"><span class="toc-text">6. 应用层</span></a>
                <ol class="toc-child">
                  <li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-远程登录"><span class="toc-text">6.1 远程登录</span></a></li>
                  <li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-文件传输"><span class="toc-text">6.2 文件传输</span></a></li>
                  <li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-电子邮件"><span class="toc-text">6.3 电子邮件</span></a></li>
                  <li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-万维网"><span class="toc-text">6.4 万维网</span></a></li>
                </ol>
              </li>
              <li class="toc-item toc-level-2"><a class="toc-link" href="#7-网络安全"><span class="toc-text">7. 网络安全</span></a>
                <ol class="toc-child">
                  <li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-安全协议"><span class="toc-text">7.1 安全协议</span></a>
                    <ol class="toc-child">
                      <li class="toc-item toc-level-4"><a class="toc-link" href="#IPsec-amp-VPN"><span class="toc-text">IPsec &amp; VPN</span></a></li>
                      <li class="toc-item toc-level-4"><a class="toc-link" href="#TLS-SSL-amp-HTTPS"><span class="toc-text">TLS/SSL &amp; HTTPS</span></a></li>
                    </ol>
                  </li>
                </ol>
              </li>
            </ol>
          </div>
        </div>
      </div>

      <div class="row">
        <!-- Sidebar Container -->

        <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

          <!-- Featured Tags -->

          <section>
            <!-- no hr -->
            <h5 class="text-center">
              <a href="/tags/">FEATURED TAGS</a>
            </h5>
            <div class="tags">

              <a class="tag" href="/tags/#Networks" title="Networks">Networks</a>

            </div>
          </section>


          <!-- Friends Blog -->

        </div>
      </div>

    </div>
  </article>
  <!-- Footer -->
  <!-- Footer -->
  <footer>
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
          <br>
          <ul class="list-inline text-center">





            <li>
              <a target="_blank" href="http://weibo.com/1757057895">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>



            <li>
              <a target="_blank" href="https://www.facebook.com/100005656009098">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>



            <li>
              <a target="_blank" href="https://github.com/wanghdnku">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>




          </ul>
          <p class="copyright text-muted">
            Copyright &copy; Hayden 2020
            <br>
            <span id="busuanzi_container_site_pv" style="font-size: 12px;">PV: <span id="busuanzi_value_site_pv"></span> Times</span>
            <br>
          </p>

        </div>
      </div>
    </div>
  </footer>

  <!-- jQuery -->
  <script src="../../../../js/jquery.min.js"></script>

  <!-- Bootstrap Core JavaScript -->
  <script src="../../../../js/bootstrap.min.js"></script>

  <!-- Custom Theme JavaScript -->
  <script src="../../../../js/blog.js"></script>

  <!-- async load function -->
  <script>
    function async (u, c) {
      var d = document,
        t = 'script',
        o = d.createElement(t),
        s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) {
        o.addEventListener('load', function(e) {
          c(null, e);
        }, false);
      }
      s.parentNode.insertBefore(o, s);
    }
  </script>

  <!-- jquery.tagcloud.js -->
  <script>
    // only load tagcloud.js in tag.html
    if ($('#tag_cloud').length !== 0) {
      async ("blog.hayden.fun/js/jquery.tagcloud.js", function() {
        $.fn.tagcloud.defaults = {
          //size: {start: 1, end: 1, unit: 'em'},
          color: {
            start: '#bbbbee',
            end: '#0085a1'
          },
        };
        $('#tag_cloud a').tagcloud();
      })
    }
  </script>

  <!--fastClick.js -->
  <script>
    async ("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function() {
      var $nav = document.querySelector("nav");
      if ($nav) FastClick.attach($nav);
    })
  </script>

  <!-- Google Analytics -->



  <!-- Baidu Tongji -->


  <!-- swiftype -->
  <script type="text/javascript">
    (function(w, d, t, u, n, s, e) {
      w['SwiftypeObject'] = n;
      w[n] = w[n] || function() {
        (w[n].q = w[n].q || []).push(arguments);
      };
      s = d.createElement(t);
      e = d.getElementsByTagName(t)[0];
      s.async = 1;
      s.src = u;
      e.parentNode.insertBefore(s, e);
    })(window, document, 'script', '//s.swiftypecdn.com/install/v2/st.js', '_st');

    _st('install', '', '2.0.0');
  </script>

  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <!--wechat title img-->
  <img class="wechat-title-img" src="http://ww1.sinaimg.cn/mw690/68ba9367ly1fo8dsy3y18j21cj1cj1kx.jpg"><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<!-- End: Injected MathJax --><!-- hexo-inject:end -->
</body>

</html>